#!/usr/bin/env python2

"""
    thermalctld
    Thermal control daemon for SONiC
"""

try:
    import os
    import sys
    import time
    import signal
    import threading
    from datetime import datetime
    from swsscommon import swsscommon
    from sonic_daemon_base import daemon_base
    from sonic_daemon_base.daemon_base import Logger
    from sonic_daemon_base.daemon_base import DaemonBase
    from sonic_daemon_base.task_base import ProcessTaskBase
    from sonic_platform_common.fan_base import FanBase
except ImportError, e:
    raise ImportError(str(e) + " - required module not found")

SYSLOG_IDENTIFIER = 'thermalctld'
NOT_AVAILABLE = 'N/A'
logger = Logger(SYSLOG_IDENTIFIER)


# utility functions

# try get information from platform API and return a default value if caught NotImplementedError
def try_get(callback, default=NOT_AVAILABLE):
    """
    Handy function to invoke the callback and catch NotImplementedError
    :param callback: Callback to be invoked
    :param default: Default return value if exception occur
    :return: Default return value if exception occur else return value of the callback
    """
    try:
        ret = callback()
    except NotImplementedError:
        ret = None

    return default if ret is None else ret


def log_on_status_changed(normal_status, normal_log, abnormal_log):
    """
    Log when any status changed
    :param normal_status: Expected status.
    :param normal_log: Log string for expected status.
    :param abnormal_log: Log string for unexpected status
    :return:
    """
    if normal_status:
        logger.log_notice(normal_log)
    else:
        logger.log_warning(abnormal_log)


class FanStatus(object):
    def __init__(self):
        """
        Constructor of FanStatus
        """
        self.presence = True
        self.under_speed = False
        self.over_speed = False
        self.invalid_direction = False

    def set_presence(self, presence):
        """
        Set and cache Fan presence status
        :param presence: Fan presence status
        :return: True if status changed else False
        """
        if presence == self.presence:
            return False

        self.presence = presence
        return True

    def _check_speed_value_available(self, speed, target_speed, tolerance, current_status):
        if speed == NOT_AVAILABLE or target_speed == NOT_AVAILABLE or tolerance == NOT_AVAILABLE:
            if current_status is True:
                logger.log_warning('Fan speed or target_speed or tolerance become unavailable.')
            return False
        return True

    def set_under_speed(self, speed, target_speed, tolerance):
        """
        Set and cache Fan under speed status
        :param speed: Fan speed
        :param target_speed: Fan target speed
        :param tolerance: Threshold between Fan speed and target speed
        :return: True if status changed else False
        """
        if not self._check_speed_value_available(speed, target_speed, tolerance, self.under_speed):
            old_status = self.under_speed
            self.under_speed = False
            return old_status != self.under_speed

        status = (target_speed - speed > tolerance)
        if status == self.under_speed:
            return False

        self.under_speed = status
        return True

    def set_over_speed(self, speed, target_speed, tolerance):
        """
        Set and cache Fan over speed status
        :param speed: Fan speed
        :param target_speed: Fan target speed
        :param tolerance: Threshold between Fan speed and target speed
        :return: True if status changed else False
        """
        if not self._check_speed_value_available(speed, target_speed, tolerance, self.over_speed):
            old_status = self.over_speed
            self.over_speed = False
            return old_status != self.over_speed

        status = (speed - target_speed > tolerance)
        if status == self.over_speed:
            return False

        self.over_speed = status
        return True

    def is_ok(self):
        """
        Indicate the Fan works as expect
        :return: True if Fan works normal else False
        """
        return self.presence and not self.under_speed and not self.over_speed and not self.invalid_direction


#
# FanUpdater ===================================================================
#
class FanUpdater(object):
    # Fan information table name in database
    FAN_INFO_TABLE_NAME = 'FAN_INFO'

    def __init__(self, chassis):
        """
        Constructor for FanUpdater
        :param chassis: Object representing a platform chassis
        """
        self.chassis = chassis
        self.fan_status_dict = {}
        state_db = daemon_base.db_connect(swsscommon.STATE_DB)
        self.table = swsscommon.Table(state_db, FanUpdater.FAN_INFO_TABLE_NAME)

    def destroy(self):
        """
        Destructor of FanUpdater
        :return:
        """
        for name in self.fan_status_dict.keys():
            self.table._del(name)

    def update(self):
        """
        Update all Fan information to database
        :return:
        """
        logger.log_info("Start fan updating")
        for index, fan in enumerate(self.chassis.get_all_fans()):
            self._refresh_fan_status(fan, index)

        for psu_index, psu in enumerate(self.chassis.get_all_psus()):
            psu_name = try_get(psu.get_name, 'PSU {}'.format(psu_index))
            for fan_index, fan in psu.get_all_fans():
                self._refresh_fan_status(fan, fan_index, '{} FAN'.format(psu_name))

        logger.log_info("Stop fan updating")

    def _refresh_fan_status(self, fan, index, name_prefix='FAN'):
        """
        Get Fan status by platform API and write to database for a given Fan
        :param fan: Object representing a platform Fan
        :param index: Index of the Fan object in the platform
        :param name_prefix: name prefix of Fan object if Fan.get_name not presented
        :return:
        """
        fan_name = try_get(fan.get_name, '{} {}'.format(name_prefix, index + 1))
        if fan_name not in self.fan_status_dict:
            self.fan_status_dict[fan_name] = FanStatus()

        fan_status = self.fan_status_dict[fan_name]

        presence = try_get(fan.get_presence, False)
        speed = try_get(fan.get_speed)
        speed_tolerance = try_get(fan.get_speed_tolerance)
        speed_target = try_get(fan.get_target_speed)

        set_led = False
        if fan_status.set_presence(presence):
            set_led = True
            log_on_status_changed(fan_status.presence,
                                  'Fan removed warning cleared: {} was inserted.'.format(fan_name),
                                  'Fan removed warning: {} was removed from '
                                  'the system, potential overheat hazard'.format(fan_name)
                                  )

        if fan_status.set_under_speed(speed, speed_target, speed_tolerance):
            set_led = True
            log_on_status_changed(not fan_status.under_speed,
                                  'Fan under speed warning cleared: {} speed back to normal.'.format(fan_name),
                                  'Fan under speed warning: {} speed over tolerance.'.format(fan_name)
                                  )

        if fan_status.set_over_speed(speed, speed_target, speed_tolerance):
            set_led = True
            log_on_status_changed(not fan_status.over_speed,
                                  'Fan over speed warning cleared: {} speed back to normal.'.format(fan_name),
                                  'Fan over speed warning: {} speed over tolerance.'.format(fan_name)
                                  )

        # TODO: handle invalid fan direction

        if set_led:
            self._set_fan_led(fan, fan_name, fan_status)

        fvs = swsscommon.FieldValuePairs(
            [('presence', str(presence)),
             ('model', str(try_get(fan.get_model))),
             ('serial', str(try_get(fan.get_serial))),
             ('status', str(try_get(fan.get_status, False))),
             ('direction', str(try_get(fan.get_direction))),
             ('speed', str(speed)),
             ('speed_tolerance', str(speed_tolerance)),
             ('speed_target', str(speed_target)),
             ('led_status', str(try_get(fan.get_status_led))),
             ('timestamp', datetime.now().strftime('%Y%m%d %H:%M:%S'))
             ])

        self.table.set(fan_name, fvs)

    def _set_fan_led(self, fan, fan_name, fan_status):
        """
        Set fan led according to current status
        :param fan: Object representing a platform Fan
        :param fan_name: Name of the Fan object in case any vendor not implement Fan.get_name
        :param fan_status: Object representing the FanStatus
        :return:
        """
        if fan_status.is_ok():
            fan.set_status_led(FanBase.STATUS_LED_COLOR_GREEN)
        else:
            # TODO: wait for Kebo to define the mapping of fan status to led color,
            # just set it to red so far
            fan.set_status_led(FanBase.STATUS_LED_COLOR_RED)


class TemperStatus(object):
    def __init__(self):
        self.over_temper = False
        self.under_temper = False

    def _check_temper_value_available(self, temper, threshold, current_status):
        if temper == NOT_AVAILABLE or threshold == NOT_AVAILABLE:
            if current_status is True:
                logger.log_warning('Fan temperature or threshold become unavailable.')
            return False
        return True

    def set_over_temper(self, temper, threshold):
        """
        Set over temperature status
        :param temper: Temperature
        :param threshold: High threshold
        :return: True if over temperature status changed else False
        """
        if self._check_temper_value_available(temper, threshold, self.over_temper):
            old_status = self.over_temper
            self.over_temper = False
            return old_status != self.over_temper

        status = temper > threshold
        if status == self.over_temper:
            return False

        self.over_temper = status
        return True

    def set_under_temper(self, temper, threshold):
        """
        Set over temperature status
        :param temper: Temperature
        :param threshold: Low threshold
        :return: True if under temperature status changed else False
        """
        if self._check_temper_value_available(temper, threshold, self.under_temper):
            old_status = self.under_temper
            self.under_temper = False
            return old_status != self.under_temper

        status = temper < threshold
        if status == self.under_temper:
            return False

        self.under_temper = status
        return True


#
# TemperUpdater ======================================================================
#
class TemperUpdater(object):
    # Temperature information table name in database
    TEMPER_INFO_TABLE_NAME = 'TEMPERATURE_INFO'

    def __init__(self, chassis):
        """
        Constructor of TemperUpdater
        :param chassis: Object representing a platform chassis
        """
        self.chassis = chassis
        self.temper_status_dict = {}
        state_db = daemon_base.db_connect(swsscommon.STATE_DB)
        self.table = swsscommon.Table(state_db, TemperUpdater.TEMPER_INFO_TABLE_NAME)

    def destroy(self):
        """
        Destructor of TemperUpdater
        :return:
        """
        for name in self.temper_status_dict.keys():
            self.table._del(name)

    def update(self):
        """
        Update all temperature information to database
        :return:
        """
        logger.log_info("Start temperature updating")
        for index, thermal in enumerate(self.chassis.get_all_thermals()):
            self._refresh_temper_status(thermal, index)

        logger.log_info("Stop temperature updating")

    def _refresh_temper_status(self, thermal, index):
        """
        Get temperature status by platform API and write to database
        :param thermal: Object representing a platform thermal zone
        :param index: Index of the thermal object in platform chassis
        :return:
        """
        name = try_get(thermal.get_name, 'Thermal {}'.format(index + 1))
        if name not in self.temper_status_dict:
            self.temper_status_dict = TemperStatus()

        temper_status = self.temper_status_dict[name]

        temperature = try_get(thermal.get_temperature)
        high_threshold = try_get(thermal.get_high_threshold)
        low_threshold = try_get(thermal.get_low_threshold)

        warning = False
        if temper_status.set_over_temper(temperature, high_threshold):
            log_on_status_changed(not temper_status.over_temper,
                                  'High temperature warning: {} current temperature {}C, high threshold {}C'.
                                  format(name, temperature, high_threshold),
                                  'High temperature warning cleared: {} temperature restore to {}C, high threshold {}C.'.
                                  format(name, temperature, high_threshold)
                                  )
            warning = True

        if temper_status.set_under_temper(temperature, low_threshold):
            log_on_status_changed(not temper_status.under_temper,
                                  'Low temperature warning: {} current temperature {}C, low threshold {}C'.
                                  format(name, temperature, low_threshold),
                                  'Low temperature warning cleared: {} temperature restore to {}C, low threshold {}C.'.
                                  format(name, temperature, low_threshold)
                                  )
            warning = True

        fvs = swsscommon.FieldValuePairs(
            [('temperature', str(temperature)),
             ('high_threshold', str(high_threshold)),
             ('low_threshold', str(low_threshold)),
             ('warning_status', str(warning)),
             ('critical_high_threshold', NOT_AVAILABLE),
             ('critical_low_threshold', NOT_AVAILABLE),
             ('timestamp', datetime.now().strftime('%Y%m%d %H:%M:%S'))
             ])

        self.table.set(name, fvs)


class ThermalMonitor(ProcessTaskBase):
    # Initial update interval
    INITIAL_INTERVAL = 5
    # Update interval value
    UPDATE_INTERVAL = 60
    # Update elapse threshold. If update used time is larger than the value, generate a warning log.
    UPDATE_ELAPSE_THRESHOLD = 30

    def __init__(self, chassis):
        """
        Constructor for ThermalMonitor
        :param chassis: Object representing a platform chassis
        """
        ProcessTaskBase.__init__(self)
        self.fan_updater = FanUpdater(chassis)
        self.temper_updater = TemperUpdater(chassis)

    def task_worker(self):
        """
        Thread function to handle Fan status update and temperature status update
        :return:
        """
        logger.log_info("Start thermal monitoring loop")

        # Start loop to update fan, temperature info in DB periodically
        wait_time = ThermalMonitor.INITIAL_INTERVAL
        while not self.task_stopping_event.wait(wait_time):
            begin = time.time()
            self.fan_updater.update()
            self.temper_updater.update()
            elapse = time.time() - begin
            if elapse < ThermalMonitor.UPDATE_INTERVAL:
                wait_time = ThermalMonitor.UPDATE_INTERVAL - elapse
            else:
                wait_time = ThermalMonitor.INITIAL_INTERVAL

            if elapse > ThermalMonitor.UPDATE_ELAPSE_THRESHOLD:
                logger.log_warning('Update fan and temperature status takes {} seconds, '
                                   'there might be performance risk'.format(elapse))

        self.fan_updater.destroy()
        self.temper_updater.destroy()

        logger.log_info("Stop thermal monitoring loop")


#
# Daemon =======================================================================
#
class ThermalControlDaemon(DaemonBase):
    # Interval to run thermal control logical
    INTERVAL = 60

    def __init__(self):
        """
        Constructor of ThermalControlDaemon
        """
        DaemonBase.__init__(self)
        self.stop_event = threading.Event()

    # Signal handler
    def signal_handler(self, sig, frame):
        """
        Signal handler
        :param sig: Signal number
        :param frame: not used
        :return:
        """
        if sig == signal.SIGHUP:
            logger.log_info("Caught SIGHUP - ignoring...")
        elif sig == signal.SIGINT:
            logger.log_info("Caught SIGINT - exiting...")
            self.stop_event.set()
        elif sig == signal.SIGTERM:
            logger.log_info("Caught SIGTERM - exiting...")
            self.stop_event.set()
        else:
            logger.log_warning("Caught unhandled signal '" + sig + "'")

    def run(self):
        """
        Run main logical of this daemon
        :return:
        """
        logger.log_info("Starting up...")

        import sonic_platform.platform
        chassis = sonic_platform.platform.Platform().get_chassis()

        thermal_monitor = ThermalMonitor(chassis)
        thermal_monitor.task_run()

        while not self.stop_event.wait(ThermalControlDaemon.INTERVAL):
            pass  # No main thread job for now

        thermal_monitor.task_stop()

        logger.log_info("Shutdown...")


#
# Main =========================================================================
#
def main():
    thermal_control = ThermalControlDaemon()
    thermal_control.run()


if __name__ == '__main__':
    main()
