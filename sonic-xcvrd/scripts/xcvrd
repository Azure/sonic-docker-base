#!/usr/bin/env python2

"""
    xcvrd
    Transceiver information update daemon for SONiC
"""

try:
    import os
    import sys
    import time
    import threading
    import json
    import string
    import ast
    from swsscommon import swsscommon
    from sonic_daemon_base.daemon_base import DaemonBase
except ImportError, e:
    raise ImportError (str(e) + " - required module not found")

#============================= Constants =============================

PLATFORM_SPECIFIC_MODULE_NAME = "sfputil"
PLATFORM_SPECIFIC_CLASS_NAME = "SfpUtil"

# Global platform-specific sfputil class instance
platform_sfputil = None
# Global xcvr dameon util class instance
daemon_xcvrd = None

SELECT_TIMEOUT_MSECS = 1000

DOM_INFO_UPDATE_PERIOD_SECS = 60
TIME_FOR_SFP_READY_SECS = 1

SFP_STATUS_INSERTED = '1'
SFP_STATUS_REMOVED = '0'

PHYSICAL_PORT_NOT_EXIST = -1
SFP_EEPROM_NOT_READY = -2

TEMP_UNIT = 'C'
VOLT_UNIT = 'Volts'
POWER_UNIT = 'dBm'
BIAS_UNIT = 'mA'

media_settings = ''

class DaemonXcvrd(DaemonBase):
    def __init__(self):
        DaemonBase.__init__(self)

    def __exit__(self):
        DaemonBase.__exit__(self)

    # Returns path to port config file
    def get_path_to_port_config_file(self):
        (platform_path, hwsku_path) = self.get_path_to_platform_and_hwsku()
        # First check for the presence of the new 'port_config.ini' file
        port_config_file_path = "/".join([hwsku_path, "port_config.ini"])
        if not os.path.isfile(port_config_file_path):
            # port_config.ini doesn't exist. Try loading the legacy 'portmap.ini' file
            port_config_file_path = "/".join([hwsku_path, "portmap.ini"])

        return port_config_file_path

    # find out the underneath physical port list by logical name
    def logical_port_name_to_physical_port_list(self, port_name):
        if port_name.startswith("Ethernet"):
            if platform_sfputil.is_logical_port(port_name):
                return platform_sfputil.get_logical_to_physical(port_name)
            else:
                self.log_error("Invalid port '%s'" % port_name)
                return None
        else:
            return [int(port_name)]


    def load_media_settings(self):
        global media_settings
        global g_dict
        (platform, hwsku_path) = self.get_path_to_platform_and_hwsku()

        media_settings_file_path = "/".join([hwsku_path, "media_settings.json"])
        if not os.path.isfile(media_settings_file_path):
            self.log_info("xcvrd: No media file exists")
            return {}

        media_file = open(media_settings_file_path, "r")
        media_settings = media_file.read()
        g_dict = json.loads(media_settings)


    def run(self):
        global platform_sfputil
        transceiver_dict = {}

        # Load platform-specific sfputil class
        platform_sfputil = self.load_platform_util(PLATFORM_SPECIFIC_MODULE_NAME, PLATFORM_SPECIFIC_CLASS_NAME)
        if not platform_sfputil:
            self.log_error("failed to load sfputil")
            sys.exit(1)

        self.load_media_settings()
        # Load port info
        try:
            port_config_file_path = self.get_path_to_port_config_file()
            platform_sfputil.read_porttab_mappings(port_config_file_path)
            # platform_sfputil.read_port_mappings()
        except Exception, e:
            self.log_error("failed to reading port info (%s)" % str(e))
            sys.exit(2)

        # Connect to STATE_DB and create transceiver info/dom info table
        state_db = self.db_connect(swsscommon.STATE_DB)
        int_tbl = swsscommon.Table(state_db, "TRANSCEIVER_INFO")
        dom_tbl = swsscommon.Table(state_db, "TRANSCEIVER_DOM_SENSOR")

        # Connect to ASIC_DB to notify Media notifications
        asic_db = self.db_connect(swsscommon.ASIC_DB)
        media_notifier = swsscommon.NotificationProducer(asic_db,
                                                         "MEDIANOTIFICATION")

        # Connect to APPL_DB abd subscribe to PORT table notifications
        appl_db = self.db_connect(swsscommon.APPL_DB)

        sel = swsscommon.Select()
        sst = swsscommon.SubscriberStateTable(appl_db, swsscommon.APP_PORT_TABLE_NAME)
        sel.addSelectable(sst)

        # Make sure this daemon started after all port configured.
        while True:
            (state, c) = sel.select(SELECT_TIMEOUT_MSECS)
            if state == swsscommon.Select.TIMEOUT:
                continue
            if state != swsscommon.Select.OBJECT:
                self.log_warning("sel.select() did not return swsscommon.Select.OBJECT")
                continue

            (key, op, fvp) = sst.pop()
            if key in ["PortConfigDone", "PortInitDone"]:
                break

        # Post all the current interface SFP info to STATE_DB
        logical_port_list = platform_sfputil.logical
        for logical_port_name in logical_port_list:
            post_port_sfp_info_to_db(logical_port_name, int_tbl,
                                     transceiver_dict)
            post_port_dom_info_to_db(logical_port_name, dom_tbl)
            notify_media_setting(logical_port_name, transceiver_dict,
                                 media_notifier)
            transceiver_dict.clear()

        # Start the dom sensor info update timer thread
        dom_info_update = dom_info_update_task(dom_tbl)
        dom_info_update.task_run()

        # Start main loop to listen to the SFP change event.
        self.log_info("Start main loop")
        while True:
            status, port_dict = platform_sfputil.get_transceiver_change_event()
            if status:
                for key, value in port_dict.iteritems():
                    logical_port_list = platform_sfputil.get_physical_to_logical(int(key))
                    for logical_port in logical_port_list:
                        if value == SFP_STATUS_INSERTED:
                            rc = post_port_sfp_info_to_db(logical_port, int_tbl,
                                                          transceiver_dict)
                            # If we didn't get the sfp info, assuming the eeprom is not ready, give a try again.
                            if rc == SFP_EEPROM_NOT_READY:
                                time.sleep(TIME_FOR_SFP_READY_SECS)
                                post_port_sfp_info_to_db(logical_port, int_tbl,
                                                         transceiver_dict)
                            post_port_dom_info_to_db(logical_port, dom_tbl)
                            notify_media_setting(logical_port, transceiver_dict,
                                                 media_notifier)
                            transceiver_dict.clear()

                        elif value == SFP_STATUS_REMOVED:
                            del_port_sfp_dom_info_to_db(logical_port, int_tbl, dom_tbl)
                        else:
                            # TODO, SFP return error code, need handle accordingly.
                            continue
            else:
                # If get_transceiver_change_event() return error, will clean up the DB and then exit
                # TODO: next step need to define more error types to handle accordingly.
                break

        # Stop the dom info update timer
        dom_info_update.task_stop()

        # Clean all the information from DB and then exit
        logical_port_list = platform_sfputil.logical
        for logical_port_name in logical_port_list:
            del_port_sfp_dom_info_to_db(logical_port_name, int_tbl, dom_tbl)
        return 1

# Returns,
#   port_num if physical
#   logical_port:port_num if logical port and is a ganged port
#   logical_port if logical and not ganged
def get_physical_port_name(logical_port, physical_port, ganged):
    if logical_port == physical_port:
        return logical_port
    elif ganged:
        return logical_port + ":%d (ganged)" % physical_port
    else:
        return logical_port

def strip_unit_and_beautify(value, unit):
    # Strip unit from raw data
    width = len(unit)
    if value[-width:] == unit:
        value = value[:-width]

    return value

# Remove unnecessary unit from the raw data
def beautify_dom_info_dict(dom_info_dict):
    dom_info_dict['temperature'] = strip_unit_and_beautify(dom_info_dict['temperature'], TEMP_UNIT)
    dom_info_dict['voltage'] = strip_unit_and_beautify(dom_info_dict['voltage'], VOLT_UNIT)
    dom_info_dict['rx1power'] = strip_unit_and_beautify(dom_info_dict['rx1power'], POWER_UNIT)
    dom_info_dict['rx2power'] = strip_unit_and_beautify(dom_info_dict['rx2power'], POWER_UNIT)
    dom_info_dict['rx3power'] = strip_unit_and_beautify(dom_info_dict['rx3power'], POWER_UNIT)
    dom_info_dict['rx4power'] = strip_unit_and_beautify(dom_info_dict['rx4power'], POWER_UNIT)
    dom_info_dict['tx1bias'] = strip_unit_and_beautify(dom_info_dict['tx1bias'], BIAS_UNIT)
    dom_info_dict['tx2bias'] = strip_unit_and_beautify(dom_info_dict['tx2bias'], BIAS_UNIT)
    dom_info_dict['tx3bias'] = strip_unit_and_beautify(dom_info_dict['tx3bias'], BIAS_UNIT)
    dom_info_dict['tx4bias'] = strip_unit_and_beautify(dom_info_dict['tx4bias'], BIAS_UNIT)
    dom_info_dict['tx1power'] = strip_unit_and_beautify(dom_info_dict['tx1power'], POWER_UNIT)
    dom_info_dict['tx2power'] = strip_unit_and_beautify(dom_info_dict['tx2power'], POWER_UNIT)
    dom_info_dict['tx3power'] = strip_unit_and_beautify(dom_info_dict['tx3power'], POWER_UNIT)
    dom_info_dict['tx4power'] = strip_unit_and_beautify(dom_info_dict['tx4power'], POWER_UNIT)

# update all the sfp info to db
def post_port_sfp_info_to_db(logical_port_name, table, transceiver_dict):
    ganged_port = False
    ganged_member_num = 1

    physical_port_list = daemon_xcvrd.logical_port_name_to_physical_port_list(logical_port_name)
    if physical_port_list is None:
        daemon_xcvrd.log_error("No physical ports found for logical port '%s'" % logical_port_name)
        return PHYSICAL_PORT_NOT_EXIST

    if len(physical_port_list) > 1:
        ganged_port = True

    for physical_port in physical_port_list:
        if not platform_sfputil.get_presence(physical_port):
            continue

        port_name = get_physical_port_name(logical_port_name, ganged_member_num, ganged_port)
        ganged_member_num += 1

        try:
            port_info_dict = platform_sfputil.get_transceiver_info_dict(physical_port)
            if port_info_dict is not None:
                transceiver_dict[physical_port]=port_info_dict
                fvs = swsscommon.FieldValuePairs([('type', port_info_dict['type']),
                                                  ('hardwarerev', port_info_dict['hardwarerev']),
                                                  ('serialnum', port_info_dict['serialnum']),
                                                  ('manufacturename', port_info_dict['manufacturename']),
                                                  ('modelname', port_info_dict['modelname']),
                                                  ('vendor_oui',port_info_dict['vendor_oui']),
                                                  ('vendor_date',port_info_dict['vendor_date']),
                                                  ('Connector',port_info_dict['Connector']),
                                                  ('encoding',port_info_dict['encoding']),
                                                  ('ext_identifier',port_info_dict['ext_identifier']),
                                                  ('ext_rateselect_compliance',port_info_dict['ext_rateselect_compliance']),
                                                  ('cable_type',port_info_dict['cable_type']),
                                                  ('cable_length',port_info_dict['cable_length']),
                                                  ('specification_compliance',port_info_dict['specification_compliance']),
                                                  ('nominal_bit_rate',port_info_dict['nominal_bit_rate'])])
                                                  
                table.set(port_name, fvs)
            else:
                return SFP_EEPROM_NOT_READY

        except NotImplementedError:
            daemon_xcvrd.log_error("This functionality is currently not implemented for this platform")
            sys.exit(3)

# update dom sensor info to db
def post_port_dom_info_to_db(logical_port_name, table):
    ganged_port = False
    ganged_member_num = 1

    physical_port_list = daemon_xcvrd.logical_port_name_to_physical_port_list(logical_port_name)
    if physical_port_list is None:
        daemon_xcvrd.log_error("No physical ports found for logical port '%s'" % logical_port_name)
        return PHYSICAL_PORT_NOT_EXIST

    if len(physical_port_list) > 1:
        ganged_port = True

    for physical_port in physical_port_list:
        if not platform_sfputil.get_presence(physical_port):
            continue

        port_name = get_physical_port_name(logical_port_name, ganged_member_num, ganged_port)
        ganged_member_num += 1

        try:
            dom_info_dict = platform_sfputil.get_transceiver_dom_info_dict(physical_port)
            if dom_info_dict is not None:
                beautify_dom_info_dict(dom_info_dict)
                fvs = swsscommon.FieldValuePairs([('temperature', dom_info_dict['temperature']),
                                                  ('voltage', dom_info_dict['voltage']),
                                                  ('rx1power', dom_info_dict['rx1power']),
                                                  ('rx2power', dom_info_dict['rx2power']),
                                                  ('rx3power', dom_info_dict['rx3power']),
                                                  ('rx4power', dom_info_dict['rx4power']),
                                                  ('tx1bias', dom_info_dict['tx1bias']),
                                                  ('tx2bias', dom_info_dict['tx2bias']),
                                                  ('tx3bias', dom_info_dict['tx3bias']),
                                                  ('tx4bias', dom_info_dict['tx4bias']),
                                                  ('tx1power', dom_info_dict['tx1power']),
                                                  ('tx2power', dom_info_dict['tx2power']),
                                                  ('tx3power', dom_info_dict['tx3power']),
                                                  ('tx4power', dom_info_dict['tx4power'])])
                table.set(port_name, fvs)
            else:
                return SFP_EEPROM_NOT_READY

        except NotImplementedError:
            daemon_xcvrd.log_error("This functionality is currently not implemented for this platform")
            sys.exit(3)

# del sfp and dom info from db
def del_port_sfp_dom_info_to_db(logical_port_name, int_tbl, dom_tbl):
    ganged_port = False
    ganged_member_num = 1

    physical_port_list = daemon_xcvrd.logical_port_name_to_physical_port_list(logical_port_name)
    if physical_port_list is None:
        daemon_xcvrd.log_error("No physical ports found for logical port '%s'" % logical_port_name)
        return PHYSICAL_PORT_NOT_EXIST

    if len(physical_port_list) > 1:
        ganged_port = True

    for physical_port in physical_port_list:
        port_name = get_physical_port_name(logical_port_name, ganged_member_num, ganged_port)
        ganged_member_num += 1

        try:
            int_tbl._del(port_name)
            dom_tbl._del(port_name)

        except NotImplementedError:
            daemon_xcvrd.log_error("This functionality is currently not implemented for this platform")
            sys.exit(3)


def check_port_in_range(range_str, port_name):
    range_separator = '-'
    prefix_str = 'Ethernet'
    range_list = range_str.split(range_separator)
    start_num = int(range_list[0].strip()[len(prefix_str):])
    end_num = int(range_list[1].strip()[len(prefix_str):])
    find_num = int(port_name.strip()[len(prefix_str):])
    if start_num <= find_num <= end_num:
        return True
    return False


def get_media_settings_value(port_name, key):
    range_separator = '-'
    comma_separator = ','
    media_dict = {}

    # Keys under global media settings can be a list or range or list of ranges
    # Below are some examples
    # Ethernet0-Ethernet120
    # Ethernet0,Ethernet4,Ethernet8,Ethernet12,Ethernet16
    # Ethernet0-Ethernet40,Ethernet80-Ethernet120

    if "GLOBAL_MEDIA_SETTINGS" in g_dict:
        for keys in g_dict["GLOBAL_MEDIA_SETTINGS"]:
            if port_name in keys:
                media_dict = g_dict["GLOBAL_MEDIA_SETTINGS"][keys]
            elif comma_separator in keys:
                port_list = keys.split(comma_separator)
                for port in port_list:
                    if range_separator in port:
                        if check_port_in_range(port, port_name):
                            media_dict = g_dict["GLOBAL_MEDIA_SETTINGS"][keys]
                            break
            elif range_separator in keys:
                if check_port_in_range(keys, port_name):
                    media_dict = g_dict["GLOBAL_MEDIA_SETTINGS"][keys]

        # If there is a match in the global profile for a media type,
        # fetch those values
        if key[0] in media_dict:
            return media_dict[key[0]]
        elif key[1] in media_dict:
            return media_dict[key[1]]

    if "PORT_MEDIA_SETTINGS" in g_dict:
        if port_name in g_dict["PORT_MEDIA_SETTINGS"]:
            media_dict = g_dict["PORT_MEDIA_SETTINGS"][port_name]
        else:
            daemon_xcvrd.log_error("Error: No values for logical port '%s'"
                                   % port_name)
            return {}
        if key[0] in media_dict:
            return media_dict[key[0]]
        elif key[1] in media_dict:
            return media_dict[key[1]]
        elif "Default" in media_dict:
            return media_dict['Default']
        else:
            return {}


def get_media_settings_key(physical_port, transceiver_dict):
    sup_media_types = {'QSFP-DD','QSFP28','QSFP+','QSFP'}
    sup_compliance_str = '10/40G Ethernet Compliance Code'
    sup_len_str = 'Length Cable Assembly(m)'
    vendor_name_str = transceiver_dict[physical_port]['manufacturename']
    vendor_pn_str = transceiver_dict[physical_port]['modelname']
    vendor_key = string.upper(vendor_name_str) + '-' + vendor_pn_str

    media_len = ''
    if transceiver_dict[physical_port]['cable_type'] == sup_len_str:
        media_len = transceiver_dict[physical_port]['cable_length']

    media_compliance_dict_str = transceiver_dict[physical_port]['specification_compliance']
    media_compliance_dict = ast.literal_eval(media_compliance_dict_str)
    media_compliance_code = ''
    media_type = ''

    if sup_compliance_str in media_compliance_dict:
        media_compliance_code = media_compliance_dict[sup_compliance_str]

    media_type_str = transceiver_dict[physical_port]['type']

    for sup_media_key in sup_media_types:
        if sup_media_key in media_type_str:
            media_type = sup_media_key
            break
    
    media_key = ''
    if len(media_type) != 0:
        media_key += media_type
    if len(media_compliance_code) != 0:
        media_key += '-' + media_compliance_code
    if len(media_len) != 0:
        media_key += '-' + media_len + 'M'
    return [vendor_key, media_key]


def notify_media_setting(logical_port_name, transceiver_dict,
                         media_notifier):
    if len(media_settings) == 0:
        return

    ganged_port = False
    ganged_member_num = 1

    physical_port_list = daemon_xcvrd.logical_port_name_to_physical_port_list(logical_port_name)
    if physical_port_list is None:
        daemon_xcvrd.log_error("Error: No physical ports found for "
                               "logical port '%s'" % logical_port_name)
        return PHYSICAL_PORT_NOT_EXIST

    if len(physical_port_list) > 1:
        ganged_port = True

    for physical_port in physical_port_list:
        if not platform_sfputil.get_presence(physical_port):
            daemon_xcvrd.log_error("Media presence not detected during notify")
            continue

        port_name = get_physical_port_name(logical_port_name,
                                           ganged_member_num, ganged_port)
        ganged_member_num += 1
        key = get_media_settings_key(physical_port, transceiver_dict)
        media_dict = get_media_settings_value(port_name, key)

        if(len(media_dict) == 0):
            daemon_xcvrd.log_error("Error in obtainning media setting")
            return

        fvs = swsscommon.FieldValuePairs(len(media_dict) + 1)
        fvs[0] = ('port', port_name)

        index = 1
        for media_key in media_dict:
            fvs[index] = (str(media_key), json.dumps(media_dict[media_key]))
            index += 1

        media_notifier.send("media_change", "", fvs)


# Timer thread wrapper class to update dom info to DB periodically
class dom_info_update_task:
    def __init__(self, table):
        self.task_stopping_event = threading.Event()
        self.task_timer = None
        self.dom_table = table

    def task_run(self):
        if self.task_stopping_event.isSet():
            daemon_xcvrd.log_error("dom info update thread received stop event, exiting...")
            return

        logical_port_list = platform_sfputil.logical
        for logical_port_name in logical_port_list:
            post_port_dom_info_to_db(logical_port_name, self.dom_table)

        self.task_timer = threading.Timer(DOM_INFO_UPDATE_PERIOD_SECS, self.task_run)
        self.task_timer.start()

    def task_stop(self):
        self.task_stopping_event.set()
        self.task_timer.join()

def main():
    global daemon_xcvrd

    daemon_xcvrd = DaemonXcvrd()
    if not daemon_xcvrd:
        print "Failed to load xcvrd daemon utilities"
        sys.exit(1)

    daemon_xcvrd.run()

if __name__ == '__main__':
    main()
